import { Injectable, Logger } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import * as crypto from 'crypto';
import * as fs from 'fs/promises';
import * as path from 'path';

export interface VulnerabilityReport {
  id: string;
  timestamp: Date;
  scanType: 'dependency' | 'code' | 'infrastructure' | 'penetration';
  status: 'running' | 'completed' | 'failed' | 'scheduled';
  vulnerabilities: VulnerabilityFinding[];
  riskScore: number;
  recommendations: string[];
  executionTime: number;
}

export interface VulnerabilityFinding {
  id: string;
  severity: 'critical' | 'high' | 'medium' | 'low' | 'info';
  category: string;
  title: string;
  description: string;
  cve?: string;
  cvssScore?: number;
  affectedComponents: string[];
  remediation: string;
  references: string[];
  exploitability: 'confirmed' | 'probable' | 'possible' | 'unlikely';
}

export interface SecurityTestConfig {
  enabled: boolean;
  schedule: string; // cron expression
  testTypes: string[];
  depth: 'surface' | 'medium' | 'deep';
  excludePaths: string[];
  customRules: SecurityRule[];
}

export interface SecurityRule {
  id: string;
  name: string;
  type: 'static' | 'dynamic' | 'behavioral';
  pattern: string;
  severity: string;
  enabled: boolean;
}

export interface PenetrationTestResult {
  testId: string;
  timestamp: Date;
  target: string;
  methodology: string;
  findings: VulnerabilityFinding[];
  riskAssessment: RiskAssessment;
  recommendations: string[];
  compliance: ComplianceStatus;
}

export interface RiskAssessment {
  overallRisk: 'critical' | 'high' | 'medium' | 'low';
  businessImpact: number;
  likelihood: number;
  riskVector: string[];
  mitigationPriority: string[];
}

export interface ComplianceStatus {
  framework: string;
  compliant: boolean;
  gaps: string[];
  recommendations: string[];
}

@Injectable()
export class VulnerabilityAssessmentService {
  private readonly logger = new Logger(VulnerabilityAssessmentService.name);
  private readonly reportsPath: string;
  private readonly config: SecurityTestConfig;
  private scanQueue: Map<string, VulnerabilityReport> = new Map();
  private scheduledScans: Map<string, NodeJS.Timeout> = new Map();

  constructor(private configService: ConfigService) {
    this.reportsPath = path.join(process.cwd(), 'security-reports');
    this.config = {
      enabled: this.configService.get<boolean>('security.vulnerability.enabled', true),
      schedule: this.configService.get<string>('security.vulnerability.schedule', '0 2 * * *'),
      testTypes: this.configService.get<string[]>('security.vulnerability.testTypes', [
        'dependency', 'code', 'infrastructure'
      ]),
      depth: this.configService.get<'surface' | 'medium' | 'deep'>('security.vulnerability.depth', 'medium'),
      excludePaths: this.configService.get<string[]>('security.vulnerability.excludePaths', [
        'node_modules', 'dist', 'coverage'
      ]),
      customRules: this.configService.get<SecurityRule[]>('security.vulnerability.customRules', [])
    };

    this.initializeAssessment();
  }

  private async initializeAssessment(): Promise<void> {
    try {
      await fs.mkdir(this.reportsPath, { recursive: true });
      
      if (this.config.enabled) {
        this.scheduleRegularScans();
        this.logger.log('Vulnerability assessment service initialized');
      }
    } catch (error) {
      this.logger.error('Failed to initialize vulnerability assessment service', error);
    }
  }

  async performDependencyAudit(): Promise<VulnerabilityReport> {
    const reportId = this.generateReportId();
    const startTime = Date.now();

    this.logger.log(`Starting dependency vulnerability scan: ${reportId}`);

    const report: VulnerabilityReport = {
      id: reportId,
      timestamp: new Date(),
      scanType: 'dependency',
      status: 'running',
      vulnerabilities: [],
      riskScore: 0,
      recommendations: [],
      executionTime: 0
    };

    this.scanQueue.set(reportId, report);

    try {
      // Simulate dependency scanning (in real implementation, integrate with npm audit, Snyk, etc.)
      const vulnerabilities = await this.scanDependencies();
      
      report.vulnerabilities = vulnerabilities;
      report.riskScore = this.calculateRiskScore(vulnerabilities);
      report.recommendations = this.generateRecommendations(vulnerabilities);
      report.status = 'completed';
      report.executionTime = Date.now() - startTime;

      await this.saveReport(report);
      
      this.logger.log(`Dependency scan completed: ${reportId}, found ${vulnerabilities.length} vulnerabilities`);
      
      if (report.riskScore > 7) {
        await this.triggerSecurityAlert(report);
      }

      return report;
    } catch (error) {
      report.status = 'failed';
      report.executionTime = Date.now() - startTime;
      this.logger.error(`Dependency scan failed: ${reportId}`, error);
      throw error;
    }
  }

  async performCodeAnalysis(): Promise<VulnerabilityReport> {
    const reportId = this.generateReportId();
    const startTime = Date.now();

    this.logger.log(`Starting static code analysis: ${reportId}`);

    const report: VulnerabilityReport = {
      id: reportId,
      timestamp: new Date(),
      scanType: 'code',
      status: 'running',
      vulnerabilities: [],
      riskScore: 0,
      recommendations: [],
      executionTime: 0
    };

    try {
      const vulnerabilities = await this.analyzeSourceCode();
      
      report.vulnerabilities = vulnerabilities;
      report.riskScore = this.calculateRiskScore(vulnerabilities);
      report.recommendations = this.generateRecommendations(vulnerabilities);
      report.status = 'completed';
      report.executionTime = Date.now() - startTime;

      await this.saveReport(report);
      
      this.logger.log(`Code analysis completed: ${reportId}, found ${vulnerabilities.length} issues`);
      
      return report;
    } catch (error) {
      report.status = 'failed';
      report.executionTime = Date.now() - startTime;
      this.logger.error(`Code analysis failed: ${reportId}`, error);
      throw error;
    }
  }

  async performInfrastructureAssessment(): Promise<VulnerabilityReport> {
    const reportId = this.generateReportId();
    const startTime = Date.now();

    this.logger.log(`Starting infrastructure assessment: ${reportId}`);

    const report: VulnerabilityReport = {
      id: reportId,
      timestamp: new Date(),
      scanType: 'infrastructure',
      status: 'running',
      vulnerabilities: [],
      riskScore: 0,
      recommendations: [],
      executionTime: 0
    };

    try {
      const vulnerabilities = await this.assessInfrastructure();
      
      report.vulnerabilities = vulnerabilities;
      report.riskScore = this.calculateRiskScore(vulnerabilities);
      report.recommendations = this.generateRecommendations(vulnerabilities);
      report.status = 'completed';
      report.executionTime = Date.now() - startTime;

      await this.saveReport(report);
      
      this.logger.log(`Infrastructure assessment completed: ${reportId}`);
      
      return report;
    } catch (error) {
      report.status = 'failed';
      report.executionTime = Date.now() - startTime;
      this.logger.error(`Infrastructure assessment failed: ${reportId}`, error);
      throw error;
    }
  }

  async performPenetrationTest(target: string): Promise<PenetrationTestResult> {
    const testId = this.generateReportId();
    const startTime = Date.now();

    this.logger.log(`Starting penetration test: ${testId} on ${target}`);

    try {
      const findings = await this.executePenetrationTest(target);
      const riskAssessment = this.assessPenetrationTestRisk(findings);
      const compliance = this.checkComplianceStatus(findings);

      const result: PenetrationTestResult = {
        testId,
        timestamp: new Date(),
        target,
        methodology: 'OWASP Testing Guide v4.2',
        findings,
        riskAssessment,
        recommendations: this.generatePenetrationTestRecommendations(findings),
        compliance
      };

      await this.savePenetrationTestResult(result);
      
      this.logger.log(`Penetration test completed: ${testId}, found ${findings.length} issues`);
      
      return result;
    } catch (error) {
      this.logger.error(`Penetration test failed: ${testId}`, error);
      throw error;
    }
  }

  private async scanDependencies(): Promise<VulnerabilityFinding[]> {
    // In real implementation, integrate with:
    // - npm audit
    // - Snyk
    // - WhiteSource
    // - OWASP Dependency Check
    
    const mockFindings: VulnerabilityFinding[] = [
      {
        id: 'DEP-001',
        severity: 'high',
        category: 'Dependency Vulnerability',
        title: 'Prototype Pollution in lodash',
        description: 'Vulnerable version of lodash allows prototype pollution attacks',
        cve: 'CVE-2019-10744',
        cvssScore: 7.5,
        affectedComponents: ['lodash@4.17.11'],
        remediation: 'Update to lodash version 4.17.12 or higher',
        references: ['https://nvd.nist.gov/vuln/detail/CVE-2019-10744'],
        exploitability: 'probable'
      }
    ];

    return mockFindings;
  }

  private async analyzeSourceCode(): Promise<VulnerabilityFinding[]> {
    // In real implementation, integrate with:
    // - ESLint security plugin
    // - SonarQube
    // - CodeQL
    // - Semgrep
    
    const mockFindings: VulnerabilityFinding[] = [
      {
        id: 'CODE-001',
        severity: 'medium',
        category: 'Input Validation',
        title: 'Missing input sanitization',
        description: 'User input is not properly sanitized before database query',
        affectedComponents: ['src/controllers/user.controller.ts:45'],
        remediation: 'Implement proper input validation and sanitization',
        references: ['https://owasp.org/www-project-top-ten/'],
        exploitability: 'possible'
      }
    ];

    return mockFindings;
  }

  private async assessInfrastructure(): Promise<VulnerabilityFinding[]> {
    // In real implementation, integrate with:
    // - Docker security scanning
    // - Kubernetes security assessment
    // - Cloud security posture management
    // - Network security scanning
    
    const mockFindings: VulnerabilityFinding[] = [
      {
        id: 'INFRA-001',
        severity: 'low',
        category: 'Configuration',
        title: 'Default security headers missing',
        description: 'Some security headers are not configured',
        affectedComponents: ['nginx.conf'],
        remediation: 'Configure all recommended security headers',
        references: ['https://securityheaders.com/'],
        exploitability: 'unlikely'
      }
    ];

    return mockFindings;
  }

  private async executePenetrationTest(target: string): Promise<VulnerabilityFinding[]> {
    // In real implementation, integrate with:
    // - OWASP ZAP
    // - Burp Suite
    // - Nmap
    // - Metasploit (carefully)
    
    const mockFindings: VulnerabilityFinding[] = [
      {
        id: 'PENTEST-001',
        severity: 'critical',
        category: 'Authentication',
        title: 'Weak password policy',
        description: 'Password policy allows weak passwords',
        affectedComponents: [target],
        remediation: 'Implement strong password policy with complexity requirements',
        references: ['https://owasp.org/www-project-top-ten/'],
        exploitability: 'confirmed'
      }
    ];

    return mockFindings;
  }

  private calculateRiskScore(vulnerabilities: VulnerabilityFinding[]): number {
    const weights = { critical: 10, high: 7, medium: 4, low: 2, info: 1 };
    const totalScore = vulnerabilities.reduce((score, vuln) => {
      return score + (weights[vuln.severity] || 0);
    }, 0);
    
    return Math.min(10, totalScore / vulnerabilities.length || 0);
  }

  private generateRecommendations(vulnerabilities: VulnerabilityFinding[]): string[] {
    const recommendations = new Set<string>();
    
    vulnerabilities.forEach(vuln => {
      recommendations.add(vuln.remediation);
    });
    
    return Array.from(recommendations);
  }

  private assessPenetrationTestRisk(findings: VulnerabilityFinding[]): RiskAssessment {
    const criticalCount = findings.filter(f => f.severity === 'critical').length;
    const highCount = findings.filter(f => f.severity === 'high').length;
    
    let overallRisk: 'critical' | 'high' | 'medium' | 'low' = 'low';
    if (criticalCount > 0) overallRisk = 'critical';
    else if (highCount > 2) overallRisk = 'high';
    else if (highCount > 0) overallRisk = 'medium';
    
    return {
      overallRisk,
      businessImpact: criticalCount * 10 + highCount * 7,
      likelihood: findings.filter(f => f.exploitability === 'confirmed').length * 3,
      riskVector: findings.map(f => f.category),
      mitigationPriority: findings
        .filter(f => f.severity === 'critical' || f.severity === 'high')
        .map(f => f.remediation)
    };
  }

  private checkComplianceStatus(findings: VulnerabilityFinding[]): ComplianceStatus {
    const criticalFindings = findings.filter(f => f.severity === 'critical');
    
    return {
      framework: 'OWASP Top 10',
      compliant: criticalFindings.length === 0,
      gaps: criticalFindings.map(f => f.title),
      recommendations: criticalFindings.map(f => f.remediation)
    };
  }

  private generatePenetrationTestRecommendations(findings: VulnerabilityFinding[]): string[] {
    const recommendations = [
      'Implement regular security testing in CI/CD pipeline',
      'Conduct security code reviews',
      'Provide security training for development team'
    ];
    
    return recommendations.concat(findings.map(f => f.remediation));
  }

  private async saveReport(report: VulnerabilityReport): Promise<void> {
    const filePath = path.join(this.reportsPath, `${report.id}-${report.scanType}.json`);
    await fs.writeFile(filePath, JSON.stringify(report, null, 2));
  }

  private async savePenetrationTestResult(result: PenetrationTestResult): Promise<void> {
    const filePath = path.join(this.reportsPath, `${result.testId}-pentest.json`);
    await fs.writeFile(filePath, JSON.stringify(result, null, 2));
  }

  private async triggerSecurityAlert(report: VulnerabilityReport): Promise<void> {
    this.logger.error(`HIGH RISK VULNERABILITIES DETECTED in scan ${report.id}`, {
      riskScore: report.riskScore,
      vulnerabilityCount: report.vulnerabilities.length,
      criticalCount: report.vulnerabilities.filter(v => v.severity === 'critical').length
    });
    
    // In real implementation, send alerts via email, Slack, etc.
  }

  private scheduleRegularScans(): void {
    // Schedule daily dependency scans
    const depScanInterval = setInterval(() => {
      this.performDependencyAudit().catch(error => {
        this.logger.error('Scheduled dependency scan failed', error);
      });
    }, 24 * 60 * 60 * 1000); // 24 hours

    // Schedule weekly code analysis
    const codeScanInterval = setInterval(() => {
      this.performCodeAnalysis().catch(error => {
        this.logger.error('Scheduled code analysis failed', error);
      });
    }, 7 * 24 * 60 * 60 * 1000); // 7 days

    this.scheduledScans.set('dependency', depScanInterval);
    this.scheduledScans.set('code', codeScanInterval);
  }

  private generateReportId(): string {
    return `SEC-${Date.now()}-${crypto.randomBytes(4).toString('hex').toUpperCase()}`;
  }

  async getReportHistory(scanType?: string): Promise<VulnerabilityReport[]> {
    try {
      const files = await fs.readdir(this.reportsPath);
      const reports: VulnerabilityReport[] = [];
      
      for (const file of files) {
        if (file.endsWith('.json') && (!scanType || file.includes(scanType))) {
          const filePath = path.join(this.reportsPath, file);
          const content = await fs.readFile(filePath, 'utf-8');
          reports.push(JSON.parse(content));
        }
      }
      
      return reports.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());
    } catch (error) {
      this.logger.error('Failed to retrieve report history', error);
      return [];
    }
  }

  async getComplianceReport(): Promise<any> {
    const reports = await this.getReportHistory();
    const latestReport = reports[0];
    
    if (!latestReport) {
      return { compliant: false, message: 'No security assessments available' };
    }
    
    const criticalVulns = latestReport.vulnerabilities.filter(v => v.severity === 'critical');
    const highVulns = latestReport.vulnerabilities.filter(v => v.severity === 'high');
    
    return {
      compliant: criticalVulns.length === 0 && highVulns.length < 5,
      lastAssessment: latestReport.timestamp,
      riskScore: latestReport.riskScore,
      criticalIssues: criticalVulns.length,
      highIssues: highVulns.length,
      recommendations: latestReport.recommendations
    };
  }
}
