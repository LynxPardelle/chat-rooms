// This service worker can be customized!
// See https://developers.google.com/web/tools/workbox/modules
// for the list of available Workbox modules

import { clientsClaim } from 'workbox-core';
import { ExpirationPlugin } from 'workbox-expiration';
import { precacheAndRoute, createHandlerBoundToURL } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { StaleWhileRevalidate, CacheFirst, NetworkFirst } from 'workbox-strategies';

// Give the service worker control immediately once it's activated
clientsClaim();

// Precache all assets generated by your build process
// The manifest is generated by the build system (vite.config.ts)
precacheAndRoute(self.__WB_MANIFEST);

// Single page application handling
const fileExtensionRegexp = new RegExp('/[^/?]+\\.[^/]+$');
registerRoute(
  // Return false to exempt requests from being fulfilled by index.html.
  ({ request, url }) => {
    // Return true if this is a navigation request
    if (request.mode !== 'navigate') {
      return false;
    }

    // If this is a URL that starts with /api/, skip this route
    if (url.pathname.startsWith('/api/')) {
      return false;
    }

    // If this looks like a file:
    if (url.pathname.match(fileExtensionRegexp)) {
      return false;
    }

    return true;
  },
  createHandlerBoundToURL('/index.html')
);

// Cache images with a Cache First strategy
registerRoute(
  // Check to see if the request is for an image
  ({ request }) => request.destination === 'image',
  new CacheFirst({
    cacheName: 'images',
    plugins: [
      // Expire images after 30 days
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 30 * 24 * 60 * 60,
      }),
    ],
  })
);

// Cache CSS and JavaScript files with a Stale While Revalidate strategy
registerRoute(
  ({ request }) => 
    request.destination === 'style' ||
    request.destination === 'script',
  new StaleWhileRevalidate({
    cacheName: 'static-resources',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 7 * 24 * 60 * 60, // 7 days
      }),
    ],
  })
);

// Cache API responses with a Network First strategy
registerRoute(
  ({ url }) => url.origin === self.location.origin && url.pathname.startsWith('/api/'),
  new NetworkFirst({
    cacheName: 'api-responses',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 200,
        maxAgeSeconds: 12 * 60 * 60, // 12 hours
      }),
    ],
  })
);

// Background sync for messages when offline
self.addEventListener('sync', (event) => {
  if (event.tag === 'sync-messages') {
    event.waitUntil(syncMessages());
  }
});

// Push notification handling
self.addEventListener('push', (event) => {
  const data = event.data.json();
  
  const title = data.title || 'New Message';
  const options = {
    body: data.body || 'You have a new message',
    icon: './vite.svg',
    badge: './vite.svg',
    data
  };

  event.waitUntil(self.registration.showNotification(title, options));
});

// Notification click handling
self.addEventListener('notificationclick', (event) => {
  const notification = event.notification;
  notification.close();

  event.waitUntil(
    clients.matchAll({ type: 'window' }).then((clientList) => {
      if (clientList.length > 0) {
        const client = clientList[0];
        client.navigate('/');
        client.focus();
      } else {
        clients.openWindow('/');
      }
    })
  );
});

// Function to sync pending messages from IndexedDB
async function syncMessages() {
  // Implementation will depend on your IndexedDB structure
  // This is a placeholder for the actual implementation
  try {
    console.log('Syncing pending messages...');
    // Get pending messages from IndexedDB
    // Send them to the server
    return Promise.resolve();
  } catch (error) {
    console.error('Error syncing messages:', error);
    return Promise.reject(error);
  }
}
